<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>OpenDRIVE 3D Viewer</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans KR", sans-serif;
            height: 100vh; 
            overflow: hidden; 
        }
        .container {
            display: flex;
            width: 100%;
            height: 100%;
        }
        .main-content {
            flex: 3; /* ë·°ì–´ ì˜ì—­ì´ ë””ë²„ê·¸ íŒ¨ë„ë³´ë‹¤ 3ë°° ë„“ê²Œ */
            position: relative; /* ìì‹ ìš”ì†Œì˜ absolute í¬ì§€ì…”ë‹ ê¸°ì¤€ */
            height: 100%;
        }
        #viewer-container {
            width: 100%;
            height: 100%;
            position: relative; /* #controls ê°™ì€ ì˜¤ë²„ë ˆì´ ìš”ì†Œë“¤ì˜ ê¸°ì¤€ */
        }
        #viewer-container > canvas {
            display: block; /* canvasê°€ divì˜ í¬ê¸°ë¥¼ ì •í™•íˆ ë”°ë¥´ë„ë¡ */
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            max-width: 280px;
            max-height: 80vh; /* í™”ë©´ ë†’ì´ì˜ 80%ë¥¼ ë„˜ì§€ ì•Šë„ë¡ */
            padding: 15px;
            background: rgba(0,0,0,0.85);
            color: white;
            border-radius: 8px;
            transition: opacity 0.3s ease;
            overflow-y: auto; /* ë‚´ìš©ì´ ê¸¸ ê²½ìš° ìŠ¤í¬ë¡¤ */
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px); /* ë°°ê²½ ë¸”ëŸ¬ íš¨ê³¼ */
            z-index: 1500; /* íˆ´íŒë³´ë‹¤ ìœ„ì— */
        }
        #controls.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #controls h3 { margin-top: 0; }
        #controls label {
            margin-right: 15px;
            user-select: none;
            display: flex; /* ì²´í¬ë°•ìŠ¤ì™€ í…ìŠ¤íŠ¸ë¥¼ ìˆ˜í‰ ì •ë ¬ */
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            transition: color 0.2s ease;
            font-size: 13px;
            line-height: 1.4;
        }
        
        #controls label:hover {
            color: #87ceeb; /* í˜¸ë²„ ì‹œ ë°ì€ íŒŒë€ìƒ‰ */
        }
        
        #controls input[type="checkbox"] {
            margin-right: 8px;
            margin-left: 0;
            transform: scale(1.1);
            cursor: pointer;
        }
        
        #controls input[type="file"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #555;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 12px;
            cursor: pointer;
        }
        
        #controls input[type="file"]::-webkit-file-upload-button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            margin-right: 8px;
            cursor: pointer;
        }
        
        #controls hr {
            border: none;
            border-top: 1px solid rgba(255,255,255,0.3);
            margin: 12px 0;
        }
        .toggle-hint {
            font-size: 0.8em;
            opacity: 0.7;
            margin: 10px 0 0 0;
            text-align: center;
        }
        #info-tooltip {
            position: fixed;
            display: none;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none; /* íˆ´íŒì´ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë¥¼ ê°€ë¡œì±„ì§€ ì•Šë„ë¡ ì„¤ì • */
            white-space: pre;
            z-index: 1800; /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ë³´ë‹¤ ìœ„ì— */
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            backdrop-filter: blur(3px);
            max-width: 300px;
            word-wrap: break-word;
        }
        .message-popup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            z-index: 1900; /* íˆ´íŒê³¼ ì»¨íŠ¸ë¡¤ íŒ¨ë„ë³´ë‹¤ ìœ„ì— */
            opacity: 0.95;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            font-size: 14px;
            max-width: 90vw;
            text-align: center;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 0.95;
            }
        }
        .success-message {
            background-color: #28a745;
        }
        .error-message {
            background-color: #dc3545;
        }
        .debug-panel {
            flex: 1; /* main-contentì™€ 3:1 ë¹„ìœ¨ì„ ë§ì¶”ê¸° ìœ„í•´ 1ë¡œ ìˆ˜ì • */
            height: 100vh;
            overflow-y: auto;
            border-left: 3px solid #ddd;
            padding: 1.2em;
            background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f4 100%);
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 0.75em;
            position: relative;
        }
        
        /* ğŸ¯ ë””ë²„ê·¸ íŒ¨ë„ ìŠ¤í¬ë¡¤ë°” ìŠ¤íƒ€ì¼ë§ (ì»¤ì„œ ë£°: ì‚¬ìš©ì ê²½í—˜) */
        .debug-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .debug-panel::-webkit-scrollbar-track {
            background: #e9ecef;
            border-radius: 4px;
        }
        
        .debug-panel::-webkit-scrollbar-thumb {
            background: #adb5bd;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        .debug-panel::-webkit-scrollbar-thumb:hover {
            background: #6c757d;
        }
        
        .debug-panel h3 {
            margin-top: 0;
            margin-bottom: 1em;
            padding-bottom: 0.5em;
            border-bottom: 2px solid #dee2e6;
            color: #495057;
            font-size: 1.1em;
            position: sticky;
            top: 0;
            background: inherit;
            z-index: 10;
        }
        
        #debug-output {
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
            color: #212529;
            background: #ffffff;
            padding: 1em;
            border-radius: 6px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }
        h1, h3 {
            font-weight: 700;
        }
        button {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans KR", sans-serif;
            padding: 5px 10px;
            cursor: pointer;
        }
        .popup {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 0.9em;
            z-index: 100;
        }
        
        /* ğŸ¯ ë¡œë”© ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼ (ì»¤ì„œ ë£°: ì‚¬ìš©ì ê²½í—˜) */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.1em;
            z-index: 2000; /* ê°€ì¥ ìœ„ì— í‘œì‹œ */
        }
        
        #loading-overlay .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #loading-text {
            margin: 0;
            text-align: center;
        }
        
        /* ğŸ¯ ë°˜ì‘í˜• ë””ìì¸ (ì»¤ì„œ ë£°: ì‚¬ìš©ì ê²½í—˜ ìµœì í™”) */
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            .main-content {
                flex: none;
                height: 60vh;
            }
            
            .debug-panel {
                flex: none;
                height: 40vh;
                border-left: none;
                border-top: 3px solid #ddd;
            }
            
            #controls {
                max-width: 240px;
                max-height: 50vh;
                font-size: 12px;
            }
        }
        
        @media (max-width: 768px) {
            #controls {
                position: fixed;
                top: 5px;
                right: 5px;
                left: auto;
                max-width: 200px;
                max-height: 40vh;
                font-size: 11px;
                padding: 10px;
            }
            
            #controls h3 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            #info-tooltip {
                font-size: 11px;
                max-width: 250px;
                padding: 8px;
            }
            
            .message-popup {
                bottom: 10px;
                font-size: 12px;
                padding: 10px 16px;
                max-width: 95vw;
            }
        }
        
        /* ğŸ¯ ê³ í•´ìƒë„ ë””ìŠ¤í”Œë ˆì´ ìµœì í™” */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            #info-tooltip {
                font-size: 14px;
            }
            
            #controls {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div id="loading-overlay">
                <div class="spinner"></div>
                <p id="loading-text">WASM ëª¨ë“ˆ ë¡œë”© ì¤‘...</p>
            </div>
            <div id="controls">
                <h3>íŒŒì¼</h3>
                <input type="file" id="file-input" accept=".xodr">
                <hr>
                
                <h3>ë ˆì´ì–´ ì œì–´</h3>
                <label><input type="checkbox" id="show-lanes" checked> ë„ë¡œ í‘œë©´ (ì§„íšŒìƒ‰)</label>
                <label><input type="checkbox" id="show-roadmarks" checked> ë„ë¡œí‘œì‹œ (í°ìƒ‰)</label>
                <label><input type="checkbox" id="show-road-objects" checked> ë„ë¡œì‹œì„¤ë¬¼ (ì´ˆë¡ìƒ‰)</label>
                <label><input type="checkbox" id="show-origin" checked> ì¤‘ì‹¬ì  í‘œì‹œ (ë¹¨ê°„ìƒ‰)</label>
                <label><input type="checkbox" id="show-original-origin" checked> ì‹¤ì œ ì›ì  (0,0) (ì£¼í™©ìƒ‰)</label>
                <label><input type="checkbox" id="show-axes" checked> ì¢Œí‘œì¶• (RGB)</label>
                <p class="toggle-hint">(H í‚¤ë¡œ íŒ¨ë„ í† ê¸€)</p>
            </div>
            <div id="info-tooltip"></div>

            <div id="viewer-container">
                <!-- 3D ë·°ì–´ê°€ ì—¬ê¸°ì— ë Œë”ë§ë©ë‹ˆë‹¤. -->
            </div>
        </div>
        <div class="debug-panel">
            <h3>ë””ë²„ê·¸ ì¶œë ¥</h3>
            <pre id="debug-output">íŒŒì‹±ëœ ë°ì´í„°ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...</pre>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script src="ModuleOpenDrive.js"></script>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import Stats from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/stats.module.js';

        let scene, camera, renderer, controls, stats;
        let lanesGroup, roadmarksGroup, roadObjectsGroup, gridHelper;
        let originMarker, coordinateAxes, originalOriginMarker;
        let highlightedObject = null;
        let originalMaterial = null;
        const highlightMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0x666600 });
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---

        function showLoading(message) {
            document.getElementById('loading-text').textContent = message;
            document.getElementById('loading-overlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }

        function showMessage(message, type = 'info') {
            const popup = document.createElement('div');
            popup.className = `message-popup ${type}`;
            popup.textContent = message;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 5000);
        }

        // --- ì´ˆê¸°í™” ë° ë©”ì¸ ë¡œì§ ---

        (async function init() {
            try {
                showLoading('WASM ëª¨ë“ˆ ë¡œë”© ì¤‘...');
                const libOpenDriveModule = await libOpenDrive();
                console.log('libOpenDRIVE ëª¨ë“ˆ:', libOpenDriveModule);
                window.Module = libOpenDriveModule;
                
                init3DScene();

                const defaultUrl = 'Maps/Germany_2018.xodr';
                const urlParams = new URLSearchParams(window.location.search);
                const loadUrl = urlParams.get('load') || defaultUrl;

                if (loadUrl) {
                    await loadAndParseUrl(loadUrl);
                }

            } catch (error) {
                console.error('ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                showMessage(`ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        })();

        // --- 3D ë·°ì–´ ì„¤ì • ---

        function init3DScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202020);
            
            const viewerContainer = document.getElementById('viewer-container');
            const width = viewerContainer.clientWidth;
            const height = viewerContainer.clientHeight;

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 20000);
            camera.position.set(50, 50, 50);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            viewerContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            
            stats = new Stats();
            document.getElementById('viewer-container').appendChild(stats.dom);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(0.5, 1, 0.5).normalize();
            scene.add(directionalLight);

            gridHelper = new THREE.GridHelper(100, 10);
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onMouseClick, false);
            
            animate();
        }

        function onWindowResize() {
            const viewerContainer = document.getElementById('viewer-container');
            const width = viewerContainer.clientWidth;
            const height = viewerContainer.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            stats.update();
            renderer.render(scene, camera);
        }

        function onMouseMove(event) {
            const infoTooltip = document.getElementById('info-tooltip');
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            infoTooltip.style.left = (event.clientX + 15) + 'px';
            infoTooltip.style.top = (event.clientY + 15) + 'px';

            raycaster.setFromCamera(mouse, camera);

            // ğŸ¯ ì›ì  ë§ˆì»¤ì™€ ì¢Œí‘œì¶•ë„ ê°ì§€ ëŒ€ìƒì— í¬í•¨ (ì»¤ì„œ ë£°: ì‹œìŠ¤í…œ ì‚¬ê³ )
            const allObjects = [
                ...lanesGroup.children, 
                ...roadmarksGroup.children, 
                ...roadObjectsGroup.children
            ];
            
            // ì›ì  ë§ˆì»¤ë“¤ ì¶”ê°€
            if (originMarker && originMarker.visible) {
                allObjects.push(originMarker);
            }
            if (originalOriginMarker && originalOriginMarker.visible) {
                allObjects.push(originalOriginMarker);
            }
            
            // ì¢Œí‘œì¶• ì¶”ê°€
            if (coordinateAxes && coordinateAxes.visible) {
                allObjects.push(...coordinateAxes.children);
            }
            
            const intersects = raycaster.intersectObjects(allObjects, true);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const point = intersection.point;
                const obj = intersection.object;
                const face = intersection.face;

                let infoText = `ì¢Œí‘œ: (${point.x.toFixed(2)}, ${point.z.toFixed(2)})`;
                if (obj.userData && obj.userData.type) {
                    infoText += `\níƒ€ì…: ${obj.userData.type}`;
                    if (obj.userData.id) {
                        infoText += `\nID: ${obj.userData.id}`;
                    }

                    // ğŸ¯ ì›ì  ë§ˆì»¤ë“¤ì— ëŒ€í•œ íŠ¹ë³„í•œ ì •ë³´ í‘œì‹œ (ì»¤ì„œ ë£°: ì‚¬ìš©ì ê²½í—˜)
                    if (obj.userData.isOrigin) {
                        infoText += `\nğŸ¯ ë§µ ì¤‘ì‹¬ì  (center_map=true)`;
                        infoText += `\ní‘œì‹œ ìœ„ì¹˜: (0, 0, 0)`;
                        if (window.mapOffsetX !== undefined && window.mapOffsetY !== undefined) {
                            infoText += `\nì¢Œí‘œ ì˜¤í”„ì…‹: X=${window.mapOffsetX.toFixed(3)}, Y=${window.mapOffsetY.toFixed(3)}`;
                        }
                    }
                    // ğŸ¯ ì‹¤ì œ OpenDRIVE ì›ì ì— ëŒ€í•œ ì •ë³´ í‘œì‹œ
                    else if (obj.userData.isRealOrigin) {
                        infoText += `\nğŸ¯ ì‹¤ì œ OpenDRIVE ì›ì  (0,0)`;
                        infoText += `\nOpenDRIVE ì¢Œí‘œ: (0, 0)`;
                        if (window.mapAnalysis) {
                            infoText += `\nìœ„ì¹˜: ${window.mapAnalysis.quadrant}`;
                            const bounds = window.mapAnalysis.bounds;
                            infoText += `\në§µ ê²½ê³„: X(${bounds.min.x.toFixed(1)}~${bounds.max.x.toFixed(1)})`;
                            infoText += `\në§µ ê²½ê³„: Z(${bounds.min.z.toFixed(1)}~${bounds.max.z.toFixed(1)})`;
                        }
                    }
                    // ğŸ¯ ì¢Œí‘œì¶•ì— ëŒ€í•œ ì •ë³´ í‘œì‹œ
                    else if (obj.userData.axis) {
                        infoText += `\nğŸ§­ ${obj.userData.axis}ì¶•`;
                        if (obj.userData.axis === 'X') {
                            infoText += ` (ë¹¨ê°•ìƒ‰, ë™ìª½ ë°©í–¥)`;
                        } else if (obj.userData.axis === 'Y') {
                            infoText += ` (ì´ˆë¡ìƒ‰, ë¶ìª½ ë°©í–¥)`;
                        } else if (obj.userData.axis === 'Z') {
                            infoText += ` (íŒŒë‘ìƒ‰, ìœ„ìª½ ë°©í–¥)`;
                        }
                    }
                    // ì¼ë°˜ ë„ë¡œ ê°ì²´ì— ëŒ€í•œ ì •ë³´
                    else {
                        const odrMesh = obj.userData.odrMesh;
                        if (odrMesh && face) {
                            const vertexIndex = face.a;
                            try {
                                if (odrMesh.get_road_id) {
                                    const roadId = odrMesh.get_road_id(vertexIndex);
                                    infoText += `\në„ë¡œ ID: ${roadId}`;
                                }
                                if (odrMesh.get_lane_id) {
                                    const laneId = odrMesh.get_lane_id(vertexIndex);
                                    const laneSecS0 = odrMesh.get_lanesec_s0(vertexIndex);
                                    infoText += `\nì°¨ì„  ì„¹ì…˜ s0: ${laneSecS0.toFixed(2)}`;
                                    infoText += `\nì°¨ì„  ID: ${laneId}`;
                                }
                            } catch (e) {
                                // C++ ì¸¡ì—ì„œ ì •ë³´ë¥¼ ì°¾ì§€ ëª»í•˜ëŠ” ê²½ìš° ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ
                                // console.warn(`ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨ (ì¸ë±ìŠ¤: ${vertexIndex}):`, e);
                            }
                        }
                    }
                }
                
                infoTooltip.innerHTML = infoText;
                infoTooltip.style.display = 'block';
            } else {
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -gridHelper.position.y);
                const intersectionPoint = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                    let infoText = `ì¢Œí‘œ: (${intersectionPoint.x.toFixed(2)}, ${intersectionPoint.z.toFixed(2)})`;
                    infoTooltip.innerHTML = infoText;
                    infoTooltip.style.display = 'block';
                } else {
                    infoTooltip.style.display = 'none';
                }
            }
        }

        // --- íŒŒì¼ íŒŒì‹± ë° ë°ì´í„° ì²˜ë¦¬ ---

        async function loadAndParseUrl(url) {
            try {
                showLoading(`[AutoLoad] ${url} íŒŒì¼ ë¡œë“œ ì¤‘...`);
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`íŒŒì¼ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${response.statusText}`);
                }
                const buffer = await response.arrayBuffer();
                console.log(`[AutoLoad] íŒŒì¼ ë¡œë“œ ì™„ë£Œ: ${url}, í¬ê¸°: ${buffer.byteLength} bytes`);
                await parseXODR(buffer);
                showMessage("ë§µ ë¡œë”© ë° íŒŒì‹± ì„±ê³µ!", "success");
            } catch (error) {
                console.error('[AutoLoad] ìë™ ë¡œë“œ ì‹¤íŒ¨:', error);
                showMessage(error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        async function parseXODR(buffer) {
            const outputEl = document.getElementById('debug-output');
            try {
                console.log("[Phase 1.3] OpenDRIVE íŒŒì‹±ì„ ì‹œì‘í•©ë‹ˆë‹¤...");
                const fileName = "Germany_2018.xodr";
                Module.FS_createDataFile("/", fileName, new Uint8Array(buffer), true, true);
                
                const config = {
                    with_lateralProfile: true,
                    with_laneHeight: true,
                    with_road_objects: true,
                    center_map: true,
                    abs_z_for_for_local_road_obj_outline: false
                };
                
                const map = new Module.OpenDriveMap(fileName, config);
                
                // ğŸ¯ ë§µ ì˜¤í”„ì…‹ ì •ë³´ë¥¼ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥ (ì»¤ì„œ ë£°: ë°ì´í„° ìº¡ìŠí™”)
                window.mapOffsetX = map.x_offs;
                window.mapOffsetY = map.y_offs;
                console.log(`ë§µ ì¢Œí‘œ ì˜¤í”„ì…‹: X=${window.mapOffsetX}, Y=${window.mapOffsetY}`);
                
                const roadNetworkMesh = Module.get_road_network_mesh(map, 0.5);
                
                displayDebugData(map, roadNetworkMesh);
                init3DViewer(roadNetworkMesh);

                map.delete();
                Module.FS_unlink(fileName);

            } catch (e) {
                console.error("parseXODR í•¨ìˆ˜ì—ì„œ ì‹¬ê°í•œ ì˜¤ë¥˜ ë°œìƒ:", e);
                if(outputEl) {
                    outputEl.textContent = "íŒŒì‹± ì¤‘ ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\\n\\n" + e.stack;
                }
                throw e; // ìƒìœ„ catch ë¸”ë¡ìœ¼ë¡œ ì—ëŸ¬ë¥¼ ë‹¤ì‹œ ë˜ì ¸ ì‚¬ìš©ìì—ê²Œ íŒì—… ì•Œë¦¼
            }
        }

        function init3DViewer(roadNetworkMesh) {
            console.log("Phase 2: 3D ë·°ì–´ ì´ˆê¸°í™”ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
            clearScene();

            lanesGroup = new THREE.Group();
            lanesGroup.name = "Lanes";
            roadmarksGroup = new THREE.Group();
            roadmarksGroup.name = "Roadmarks";
            roadObjectsGroup = new THREE.Group();
            roadObjectsGroup.name = "RoadObjects";

            const laneMaterial = new THREE.MeshStandardMaterial({ color: 0x505050, side: THREE.DoubleSide });
            laneMaterial.name = "Lanes";
            const roadmarkMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            roadmarkMaterial.name = "Roadmarks";
            const roadObjectMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4444, // ë” ëˆˆì— ë„ëŠ” ë¹¨ê°„ìƒ‰
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            roadObjectMaterial.name = "RoadObjects";

            // ì°¨ì„  ë©”ì‰¬
            const odrLanesMesh = roadNetworkMesh.lanes_mesh;
            const lanesMesh = createThreeMeshFromOdrMesh(odrLanesMesh, laneMaterial);
            if (lanesMesh) {
                lanesMesh.userData = { 
                    type: 'ë„ë¡œ í‘œë©´',
                    odrMesh: odrLanesMesh 
                };
                lanesGroup.add(lanesMesh);
            }
            
            // ë„ë¡œ í‘œì‹œ ë©”ì‰¬
            const odrRoadmarksMesh = roadNetworkMesh.roadmarks_mesh;
            const roadmarksMesh = createThreeMeshFromOdrMesh(odrRoadmarksMesh, roadmarkMaterial);
            if (roadmarksMesh) {
                roadmarksMesh.userData = { 
                    type: 'ë„ë¡œ í‘œì‹œ',
                    odrMesh: odrRoadmarksMesh
                };
                roadmarksGroup.add(roadmarksMesh);
            }
            
            // ë„ë¡œ ì‹œì„¤ë¬¼ ë©”ì‰¬ (ê°œë³„)
            if (roadNetworkMesh.road_objects_mesh && roadNetworkMesh.road_objects_mesh.road_object_start_indices) {
                const objectCount = roadNetworkMesh.road_objects_mesh.road_object_start_indices.size();
                console.log(`ğŸš§ ë„ë¡œì‹œì„¤ë¬¼ ì²˜ë¦¬ ì‹œì‘: ${objectCount}ê°œ ê°ì²´ ê°ì§€ë¨`);
                createIndividualObjectMeshes(roadNetworkMesh.road_objects_mesh, roadNetworkMesh.road_objects_mesh.road_object_start_indices, roadObjectMaterial);
                
                // ìƒì„±ëœ ì‹œì„¤ë¬¼ ê°œìˆ˜ í™•ì¸
                const createdCount = roadObjectsGroup.children.length;
                if (createdCount > 0) {
                    showMessage(`âœ… ë„ë¡œì‹œì„¤ë¬¼ ${createdCount}ê°œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤! (ë¹¨ê°„ìƒ‰/ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œ)`, 'success');
                } else if (objectCount > 0) {
                    showMessage(`âš ï¸ ë„ë¡œì‹œì„¤ë¬¼ ë°ì´í„°ëŠ” ìˆì§€ë§Œ(${objectCount}ê°œ) 3D ëª¨ë¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë””ë²„ê·¸ íŒ¨ë„ì„ í™•ì¸í•˜ì„¸ìš”.`, 'warning');
                }
            } else {
                console.log("ğŸš§ ë„ë¡œì‹œì„¤ë¬¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                showMessage("â„¹ï¸ ì´ ë§µì—ëŠ” ë„ë¡œì‹œì„¤ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.", 'info');
            }

            // ì›ì ê³¼ ì¢Œí‘œì¶• í‘œì‹œ
            createOriginMarker();
            createOriginalOriginMarker();
            createCoordinateAxes();

            // ëª¨ë“  ë©”ì‰¬ ê·¸ë£¹ì„ ì”¬ì— ì¶”ê°€
            scene.add(lanesGroup);
            scene.add(roadmarksGroup);
            scene.add(roadObjectsGroup);

            // ì¹´ë©”ë¼ ë° ê·¸ë¦¬ë“œ ì—…ë°ì´íŠ¸
            const allMeshes = [lanesMesh, roadmarksMesh, ...roadObjectsGroup.children].filter(m => m);
            updateCameraAndGrid(allMeshes);
            setupLayerControls();
            
            // 3D ê·¸ë£¹ì´ ëª¨ë‘ ìƒì„±ëœ í›„ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        }

        function createThreeMeshFromOdrMesh(odrMesh, material) {
            if (!odrMesh || odrMesh.vertices.size() === 0) {
                console.warn(`[${material.name} ë©”ì‰¬] ê²½ê³ : ë Œë”ë§í•  ë©”ì‰¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`);
                return null;
            }

            const vertices = odrMesh.vertices;
            const indices = odrMesh.indices;
            const num_vertices = vertices.size();

            const reorderedVertices = new Float32Array(num_vertices * 3);
            let hasNaN = false;

            // ì¢Œí‘œê³„ ë³€í™˜: OpenDRIVE (Z-up) -> Three.js (Y-up)
            for (let i = 0; i < num_vertices; i++) {
                const vert = vertices.get(i);
                const x = vert[0];
                const y = vert[1];
                const z = vert[2];

                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    hasNaN = true;
                    reorderedVertices[i * 3 + 0] = 0;
                    reorderedVertices[i * 3 + 1] = 0;
                    reorderedVertices[i * 3 + 2] = 0;
                } else {
                    reorderedVertices[i * 3 + 0] = x;
                    reorderedVertices[i * 3 + 1] = z; // Yì™€ Zë¥¼ êµí™˜
                    reorderedVertices[i * 3 + 2] = -y; // Yë¥¼ ë°˜ì „ì‹œì¼œ ì˜¤ë¥¸ì† ì¢Œí‘œê³„ ìœ ì§€
                }
            }
            
            if (hasNaN) {
                console.warn(`[${material.name} ë©”ì‰¬] ë°ì´í„°ì— NaN ê°’ì´ í¬í•¨ë˜ì–´ ìˆì–´ 0ìœ¼ë¡œ ëŒ€ì²´í–ˆìŠµë‹ˆë‹¤. ì¼ë¶€ ëª¨ë¸ì´ ì˜ëª» ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(reorderedVertices, 3));
            
            const js_indices = [];
            const indices_size = indices.size();
            for (let i = 0; i < indices_size; i++) {
                js_indices.push(indices.get(i));
            }
            geometry.setIndex(js_indices);
            geometry.computeVertexNormals();

            return new THREE.Mesh(geometry, material);
        }

        function createIndividualObjectMeshes(odrMesh, startIndices, material) {
            if (!odrMesh || odrMesh.vertices.size() === 0 || !startIndices) {
                console.warn("ğŸš§ ë„ë¡œ ì‹œì„¤ë¬¼ ë°ì´í„°ê°€ ì—†ì–´ ê°œë³„ ê°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                console.log("  - odrMesh:", !!odrMesh);
                console.log("  - vertices:", odrMesh?.vertices?.size() ?? 0);
                console.log("  - startIndices:", !!startIndices);
                return;
            }

            const vertices = odrMesh.vertices;
            const indices = odrMesh.indices;
            const totalObjects = startIndices.size();
            
            console.log(`ğŸš§ ë„ë¡œì‹œì„¤ë¬¼ ìƒì„± ì‹œì‘: ${totalObjects}ê°œ ê°ì²´ ì²˜ë¦¬`);
            console.log(`  - ì´ ì •ì : ${vertices.size()}`);
            console.log(`  - ì´ ì¸ë±ìŠ¤: ${indices.size()}`);

            let createdObjects = 0;
            let skippedObjects = 0;

            for (let i = 0; i < totalObjects - 1; i++) {
                const startIndex = startIndices.get(i);
                const endIndex = startIndices.get(i + 1);
                const indexCount = endIndex - startIndex;
                
                if (indexCount <= 0) {
                    console.warn(`  ê°ì²´ ${i}: ì¸ë±ìŠ¤ ê°œìˆ˜ê°€ 0 ì´í•˜ (${indexCount}), ê±´ë„ˆëœ€`);
                    skippedObjects++;
                    continue;
                }
                
                const geometry = new THREE.BufferGeometry();
                const objVerticesList = [];
                const objIndicesList = [];
                let hasNaN = false;

                const vertexMap = new Map();
                let nextIndex = 0;

                for (let j = startIndex; j < endIndex; j++) {
                    const originalIndex = indices.get(j);

                    if (!vertexMap.has(originalIndex)) {
                        const vert = vertices.get(originalIndex);
                        const x = vert[0];
                        const y = vert[1];
                        const z = vert[2];

                        if (isNaN(x) || isNaN(y) || isNaN(z)) {
                            hasNaN = true;
                            objVerticesList.push(0, 0, 0);
                        } else {
                            objVerticesList.push(x, z, -y); // Z-up to Y-up
                        }
                        vertexMap.set(originalIndex, nextIndex++);
                    }
                    objIndicesList.push(vertexMap.get(originalIndex));
                }

                if (hasNaN) {
                    console.warn(`  ê°ì²´ ${i}: NaN ê°’ í¬í•¨, 0ìœ¼ë¡œ ëŒ€ì²´`);
                }

                if (objVerticesList.length > 0 && objIndicesList.length > 0) {
                    const objVertices = new Float32Array(objVerticesList);
                    geometry.setAttribute('position', new THREE.BufferAttribute(objVertices, 3));
                    geometry.setIndex(objIndicesList);
                    geometry.computeVertexNormals();

                    // ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°ìœ¼ë¡œ í¬ê¸° í™•ì¸
                    geometry.computeBoundingBox();
                    const box = geometry.boundingBox;
                    const size = box.max.distanceTo(box.min);

                    const mesh = new THREE.Mesh(geometry, material.clone());
                    mesh.userData = { 
                        id: `RoadObject-${i}`, 
                        type: 'ë„ë¡œ ì‹œì„¤ë¬¼',
                        size: size.toFixed(3),
                        vertices: objVerticesList.length / 3,
                        indices: objIndicesList.length
                    };
                    
                    // ì‘ì€ ê°ì²´ëŠ” ë” ëˆˆì— ë„ê²Œ ë§Œë“¤ê¸°
                    if (size < 1.0) {
                        mesh.material.color.setHex(0xffff00); // ë…¸ë€ìƒ‰
                        mesh.material.emissive.setHex(0x444400); // ë°œê´‘ íš¨ê³¼
                    }
                    
                    roadObjectsGroup.add(mesh);
                    createdObjects++;
                    
                    console.log(`  ê°ì²´ ${i}: ìƒì„± ì™„ë£Œ (í¬ê¸°: ${size.toFixed(3)}m, ì •ì : ${objVerticesList.length/3}, ì¸ë±ìŠ¤: ${objIndicesList.length})`);
                } else {
                    console.warn(`  ê°ì²´ ${i}: ë¹ˆ ì§€ì˜¤ë©”íŠ¸ë¦¬, ê±´ë„ˆëœ€`);
                    skippedObjects++;
                }
            }
            
            console.log(`ğŸš§ ë„ë¡œì‹œì„¤ë¬¼ ìƒì„± ì™„ë£Œ: ${createdObjects}ê°œ ìƒì„±, ${skippedObjects}ê°œ ê±´ë„ˆëœ€`);
            
            // ì‹œì„¤ë¬¼ì´ í•˜ë‚˜ë„ ìƒì„±ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ëŒ€ì²´ í‘œì‹œ ìƒì„±
            if (createdObjects === 0 && totalObjects > 0) {
                console.warn("âš ï¸ ë„ë¡œì‹œì„¤ë¬¼ì´ í•˜ë‚˜ë„ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ëŒ€ì²´ ë§ˆì»¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.");
                createFallbackRoadObjectMarkers(odrMesh, startIndices);
            }
        }

        // ë„ë¡œì‹œì„¤ë¬¼ì´ í‘œì‹œë˜ì§€ ì•Šì„ ë•Œ ëŒ€ì²´ ë§ˆì»¤ ìƒì„±
        function createFallbackRoadObjectMarkers(odrMesh, startIndices) {
            const vertices = odrMesh.vertices;
            const totalObjects = startIndices.size();
            
            for (let i = 0; i < Math.min(totalObjects - 1, 10); i++) { // ìµœëŒ€ 10ê°œë§Œ
                const startIndex = startIndices.get(i);
                
                if (startIndex < vertices.size()) {
                    const vert = vertices.get(startIndex);
                    const x = vert[0];
                    const y = vert[1]; 
                    const z = vert[2];
                    
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        // êµ¬ í˜•íƒœì˜ ë§ˆì»¤ ìƒì„±
                        const geometry = new THREE.SphereGeometry(2.0, 8, 6);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: 0xff0000,
                            emissive: 0x440000,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const marker = new THREE.Mesh(geometry, material);
                        marker.position.set(x, z, -y); // ì¢Œí‘œê³„ ë³€í™˜
                        marker.userData = { 
                            id: `FallbackMarker-${i}`, 
                            type: 'ë„ë¡œ ì‹œì„¤ë¬¼ ë§ˆì»¤',
                            originalPosition: [x, y, z]
                        };
                        
                        roadObjectsGroup.add(marker);
                        console.log(`  ëŒ€ì²´ ë§ˆì»¤ ${i}: (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
                    }
                }
            }
        }

        function setupLayerControls() {
            const controlsMap = {
                'show-lanes': lanesGroup,
                'show-roadmarks': roadmarksGroup,
                'show-road-objects': roadObjectsGroup,
                'show-origin': originMarker,
                'show-original-origin': originalOriginMarker,
                'show-axes': coordinateAxes,
            };

            for (const [id, group] of Object.entries(controlsMap)) {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.removeEventListener('change', onLayerToggle);
                    checkbox.addEventListener('change', onLayerToggle);
                    if (group) {
                       group.visible = checkbox.checked;
                    }
                }
            }
        }
        
        function onLayerToggle(e) {
            const groups = {
                'show-lanes': lanesGroup,
                'show-roadmarks': roadmarksGroup,
                'show-road-objects': roadObjectsGroup,
                'show-origin': originMarker,
                'show-original-origin': originalOriginMarker,
                'show-axes': coordinateAxes,
            };
            const group = groups[e.target.id];
            if (group) {
                group.visible = e.target.checked;
                // ğŸ¯ ì›ì ê³¼ ì¢Œí‘œì¶•ì— ëŒ€í•œ íŠ¹ë³„í•œ ë¡œê¹… (ì»¤ì„œ ë£°: ì‚¬ìš©ì ê²½í—˜)
                if (e.target.id === 'show-origin') {
                    console.log(`ğŸ¯ ì¤‘ì‹¬ì  ë§ˆì»¤ ${e.target.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}: center_mapìœ¼ë¡œ ì¸í•œ ì¤‘ì‹¬ì `);
                } else if (e.target.id === 'show-original-origin') {
                    console.log(`ğŸ¯ ì‹¤ì œ ì›ì  ë§ˆì»¤ ${e.target.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}: OpenDRIVE (0,0) ìœ„ì¹˜`);
                    if (e.target.checked && window.mapAnalysis) {
                        console.log(`  ìœ„ì¹˜: ${window.mapAnalysis.quadrant}`);
                    }
                } else if (e.target.id === 'show-axes') {
                    console.log(`ğŸ¯ ì¢Œí‘œì¶• ${e.target.checked ? 'í‘œì‹œ' : 'ìˆ¨ê¹€'}: X(ë¹¨ê°•/ë™ìª½), Y(ì´ˆë¡/ë¶ìª½), Z(íŒŒë‘/ìœ„ìª½)`);
                }
            }
        }

        function updateCameraAndGrid(meshes) {
            if (meshes.length === 0) return;

            const boundingBox = new THREE.Box3();
            meshes.forEach(mesh => {
                if (mesh && mesh.geometry) {
                    mesh.geometry.computeBoundingBox();
                    const meshBoundingBox = mesh.geometry.boundingBox;
                    if (meshBoundingBox && !meshBoundingBox.isEmpty()) {
                        boundingBox.union(mesh.geometry.boundingBox);
                    }
                }
            });

            if (boundingBox.isEmpty()) {
                console.warn("ê²½ê³„ ìƒì(BoundingBox)ë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }

            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
            const size = new THREE.Vector3();
            boundingBox.getSize(size);

            const maxSize = Math.max(size.x, size.y, size.z);
            const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            const distance = 1.5 * Math.max(fitHeightDistance, fitWidthDistance);

            const direction = controls.target.clone().sub(camera.position).normalize().multiplyScalar(distance);

            controls.maxDistance = distance * 10;
            controls.target.copy(center);
            camera.position.copy(center).sub(direction);
            camera.near = distance / 100;
            camera.far = distance * 100;
            camera.updateProjectionMatrix();

            // ê·¸ë¦¬ë“œ í—¬í¼ ì—…ë°ì´íŠ¸
            scene.remove(gridHelper);
            // ë§µ í¬ê¸°ë³´ë‹¤ í¬ë©´ì„œ ê°€ì¥ ê°€ê¹Œìš´ 100ì˜ ë°°ìˆ˜ë¡œ ê·¸ë¦¬ë“œ í¬ê¸°ë¥¼ ì •í•¨
            const gridSize = Math.ceil(Math.max(size.x, size.z) / 100) * 100;
            const divisions = gridSize / 100; // ê° ì¹¸ì´ 100x100ì´ ë˜ë„ë¡ ë¶„í• 
            gridHelper = new THREE.GridHelper(gridSize, divisions, 0x888888, 0x444444);
            gridHelper.position.y = boundingBox.min.y; // ê·¸ë¦¬ë“œë¥¼ ê°ì²´ë“¤ ì•„ë˜ì— ìœ„ì¹˜
            scene.add(gridHelper);
        }

        // ğŸ“‹ **í¬ê´„ì  ë””ë²„ê·¸ ë°ì´í„° í‘œì‹œ í•¨ìˆ˜** (ì»¤ì„œ ë£°: ë‹¨ì¼ ì±…ì„ ì›ì¹™ ì ìš©)
        function displayDebugData(map, roadNetworkMesh) {
            const outputEl = document.getElementById('debug-output');
            if (!outputEl) {
                console.error("ë””ë²„ê·¸ ì¶œë ¥ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
                return;
            }

            try {
                if (!map || !roadNetworkMesh) {
                    outputEl.textContent = "ì˜¤ë¥˜: ë§µ ë˜ëŠ” ë©”ì‰¬ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
                    return;
                }

                let fullOutput = "";
                
                // ğŸ¯ 1. OpenDriveMap ê¸°ë³¸ ì •ë³´
                fullOutput += generateMapBasicInfo(map);
                
                // ğŸ¯ 2. ì „ì—­ í•¨ìˆ˜ ê²°ê³¼
                fullOutput += generateGlobalFunctionResults(map);
                
                // ğŸ¯ 3. RoadNetworkMesh ìƒì„¸ ë¶„ì„
                fullOutput += generateRoadNetworkMeshAnalysis(roadNetworkMesh);
                
                // ğŸ¯ 4. ë„ë¡œë³„ ìƒì„¸ ì •ë³´
                fullOutput += generateRoadDetailedInfo(map);
                
                // ğŸ¯ 5. êµì°¨ë¡œ ì •ë³´
                fullOutput += generateJunctionInfo(map);
                
                // ğŸ¯ 6. ë©”ì‰¬ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„°
                fullOutput += generateMeshGeometryData(roadNetworkMesh);
                
                // ğŸ¯ 7. ì°¸ì¡°ì„  ë°ì´í„°
                fullOutput += generateReflineData(map);
                
                // ğŸ¯ 8. ë§µ ìœ„ì¹˜ ë¶„ì„ ê²°ê³¼
                fullOutput += generateMapLocationAnalysis();
                
                outputEl.textContent = fullOutput;

            } catch (e) {
                console.error("displayDebugData í•¨ìˆ˜ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", e);
                outputEl.textContent = "ë””ë²„ê·¸ ì •ë³´ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n" + e.stack;
            }
        }

        // ğŸ¯ **1. OpenDriveMap ê¸°ë³¸ ì •ë³´ ì¶”ì¶œ** (ì»¤ì„œ ë£°: ë°ì´í„° ìº¡ìŠí™”)
        function generateMapBasicInfo(map) {
            let output = "=".repeat(60) + "\n";
            output += "ğŸ“ OpenDRIVE Map ê¸°ë³¸ ì •ë³´\n";
            output += "=".repeat(60) + "\n";
            
            output += `íŒŒì¼ëª…: ${map.xodr_file || 'N/A'}\n`;
            output += `ì¢Œí‘œê³„ (PROJ4): ${map.proj4 || 'None'}\n`;
            output += `X ì¢Œí‘œ ì˜¤í”„ì…‹: ${(map.x_offs ?? 0).toFixed(6)}\n`;
            output += `Y ì¢Œí‘œ ì˜¤í”„ì…‹: ${(map.y_offs ?? 0).toFixed(6)}\n`;
            output += "\n";
            
            return output;
        }

        // ğŸ¯ **2. ì „ì—­ í•¨ìˆ˜ ê²°ê³¼ ì¶”ì¶œ** (ì»¤ì„œ ë£°: ë…ë¦½ì  ë°°í¬ ê°€ëŠ¥ì„±)
        function generateGlobalFunctionResults(map) {
            let output = "=".repeat(60) + "\n";
            output += "ğŸŒ ì „ì—­ í•¨ìˆ˜ ê²°ê³¼\n";
            output += "=".repeat(60) + "\n";
            
            try {
                // Roads ë°ì´í„°
                const roads = Module.get_roads(map);
                output += `ì´ ë„ë¡œ ìˆ˜: ${roads?.size() ?? 'N/A'}\n`;
                
                // Junctions ë°ì´í„°
                const junctions = Module.get_junctions(map);
                output += `ì´ êµì°¨ë¡œ ìˆ˜: ${junctions?.size() ?? 'N/A'}\n`;
                
                // Refline Segments ë°ì´í„°
                const reflineSegments = Module.get_refline_segments(map, 0.25);
                output += `ì°¸ì¡°ì„  ì •ì  ìˆ˜: ${reflineSegments?.vertices?.size() ?? 'N/A'}\n`;
                output += `ì°¸ì¡°ì„  ì¸ë±ìŠ¤ ìˆ˜: ${reflineSegments?.indices?.size() ?? 'N/A'}\n`;
                
            } catch (e) {
                output += `ì „ì—­ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë¥˜: ${e.message}\n`;
            }
            
            output += "\n";
            return output;
        }

        // ğŸ¯ **3. RoadNetworkMesh ìƒì„¸ ë¶„ì„** (ì»¤ì„œ ë£°: ì‹œìŠ¤í…œ ì‚¬ê³ )
        function generateRoadNetworkMeshAnalysis(roadNetworkMesh) {
            let output = "=".repeat(60) + "\n";
            output += "ğŸ—ï¸ RoadNetworkMesh ìƒì„¸ ë¶„ì„\n";
            output += "=".repeat(60) + "\n";
            
            try {
                // LanesMesh ë¶„ì„
                const lanesMesh = roadNetworkMesh.lanes_mesh;
                if (lanesMesh) {
                    output += "--- ì°¨ì„  ë©”ì‰¬ (LanesMesh) ---\n";
                    output += `ì°¨ì„  ìˆ˜: ${lanesMesh.lane_start_indices?.size() ?? 0}\n`;
                    output += `ì°¨ì„ ì„¹ì…˜ ìˆ˜: ${lanesMesh.lanesec_start_indices?.size() ?? 0}\n`;
                    output += `ë„ë¡œ ìˆ˜: ${lanesMesh.road_start_indices?.size() ?? 0}\n`;
                    output += `ì´ ì •ì  ìˆ˜: ${lanesMesh.vertices?.size() ?? 0}\n`;
                    output += `ì´ ì¸ë±ìŠ¤ ìˆ˜: ${lanesMesh.indices?.size() ?? 0}\n`;
                    output += `ë²•ì„  ë²¡í„° ìˆ˜: ${lanesMesh.normals?.size() ?? 0}\n`;
                    output += `ST ì¢Œí‘œ ìˆ˜: ${lanesMesh.st_coordinates?.size() ?? 0}\n`;
                    
                    // ì²« ë²ˆì§¸ ì°¨ì„  ìƒì„¸ ì •ë³´
                    if (lanesMesh.lane_start_indices?.size() > 0) {
                        const firstLaneIdx = lanesMesh.lane_start_indices.get(0);
                        output += `\nì²« ë²ˆì§¸ ì°¨ì„  ì •ë³´:\n`;
                        output += `  - ì°¨ì„  ID: ${lanesMesh.get_lane_id(firstLaneIdx)}\n`;
                        output += `  - ë„ë¡œ ID: ${lanesMesh.get_road_id(firstLaneIdx)}\n`;
                        output += `  - ì°¨ì„ ì„¹ì…˜ S0: ${lanesMesh.get_lanesec_s0(firstLaneIdx)?.toFixed(3)}\n`;
                        
                        const laneInterval = lanesMesh.get_idx_interval_lane(firstLaneIdx);
                        output += `  - ì •ì  ì¸ë±ìŠ¤ êµ¬ê°„: [${laneInterval[0]}, ${laneInterval[1]})\n`;
                        output += `  - ì •ì  ê°œìˆ˜: ${laneInterval[1] - laneInterval[0]}\n`;
                    }
                }
                
                // RoadmarksMesh ë¶„ì„
                const roadmarksMesh = roadNetworkMesh.roadmarks_mesh;
                if (roadmarksMesh) {
                    output += "\n--- ë„ë¡œí‘œì‹œ ë©”ì‰¬ (RoadmarksMesh) ---\n";
                    output += `ë„ë¡œí‘œì‹œ íƒ€ì… ìˆ˜: ${roadmarksMesh.roadmark_type_start_indices?.size() ?? 0}\n`;
                    output += `ì´ ì •ì  ìˆ˜: ${roadmarksMesh.vertices?.size() ?? 0}\n`;
                    output += `ì´ ì¸ë±ìŠ¤ ìˆ˜: ${roadmarksMesh.indices?.size() ?? 0}\n`;
                    
                    // ì²« ë²ˆì§¸ ë„ë¡œí‘œì‹œ ìƒì„¸ ì •ë³´
                    if (roadmarksMesh.roadmark_type_start_indices?.size() > 0) {
                        const firstRoadmarkIdx = roadmarksMesh.roadmark_type_start_indices.get(0);
                        output += `\nì²« ë²ˆì§¸ ë„ë¡œí‘œì‹œ ì •ë³´:\n`;
                        output += `  - ë„ë¡œí‘œì‹œ íƒ€ì…: ${roadmarksMesh.get_roadmark_type(firstRoadmarkIdx)}\n`;
                        output += `  - ë„ë¡œ ID: ${roadmarksMesh.get_road_id(firstRoadmarkIdx)}\n`;
                        
                        const roadmarkInterval = roadmarksMesh.get_idx_interval_roadmark(firstRoadmarkIdx);
                        output += `  - ì •ì  ì¸ë±ìŠ¤ êµ¬ê°„: [${roadmarkInterval[0]}, ${roadmarkInterval[1]})\n`;
                    }
                }
                
                // RoadObjectsMesh ë¶„ì„
                const roadObjectsMesh = roadNetworkMesh.road_objects_mesh;
                if (roadObjectsMesh) {
                    output += "\n--- ë„ë¡œì‹œì„¤ë¬¼ ë©”ì‰¬ (RoadObjectsMesh) ---\n";
                    const objectCount = roadObjectsMesh.road_object_start_indices?.size() ?? 0;
                    const vertexCount = roadObjectsMesh.vertices?.size() ?? 0;
                    const indexCount = roadObjectsMesh.indices?.size() ?? 0;
                    
                    output += `ë„ë¡œì‹œì„¤ë¬¼ ìˆ˜: ${objectCount}\n`;
                    output += `ì´ ì •ì  ìˆ˜: ${vertexCount}\n`;
                    output += `ì´ ì¸ë±ìŠ¤ ìˆ˜: ${indexCount}\n`;
                    
                    if (objectCount === 0) {
                        output += `âš ï¸ ë„ë¡œì‹œì„¤ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤. OpenDRIVE íŒŒì¼ì— <object> íƒœê·¸ê°€ ì—†ê±°ë‚˜ with_road_objects=falseì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n`;
                    } else {
                        output += `âœ… ë„ë¡œì‹œì„¤ë¬¼ ë°ì´í„° ë°œê²¬! 3D ë·°ì–´ì—ì„œ ë¹¨ê°„ìƒ‰/ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.\n`;
                        
                        // ì²« ë²ˆì§¸ ë„ë¡œì‹œì„¤ë¬¼ ìƒì„¸ ì •ë³´
                        if (roadObjectsMesh.road_object_start_indices?.size() > 0) {
                            try {
                                const firstObjectIdx = roadObjectsMesh.road_object_start_indices.get(0);
                                output += `\nì²« ë²ˆì§¸ ë„ë¡œì‹œì„¤ë¬¼ ì •ë³´:\n`;
                                
                                // ID ì •ë³´ (ì•ˆì „í•˜ê²Œ ì‹œë„)
                                try {
                                    const objectId = roadObjectsMesh.get_road_object_id ? roadObjectsMesh.get_road_object_id(firstObjectIdx) : 'N/A';
                                    const roadId = roadObjectsMesh.get_road_id ? roadObjectsMesh.get_road_id(firstObjectIdx) : 'N/A';
                                    output += `  - ì‹œì„¤ë¬¼ ID: ${objectId}\n`;
                                    output += `  - ë„ë¡œ ID: ${roadId}\n`;
                                } catch (e) {
                                    output += `  - ID ì •ë³´ ì¶”ì¶œ ì‹¤íŒ¨: ${e.message}\n`;
                                }
                                
                                // ì¸ë±ìŠ¤ êµ¬ê°„ ì •ë³´
                                try {
                                    const objectInterval = roadObjectsMesh.get_idx_interval_road_object ? 
                                        roadObjectsMesh.get_idx_interval_road_object(firstObjectIdx) : null;
                                    if (objectInterval) {
                                        output += `  - ì •ì  ì¸ë±ìŠ¤ êµ¬ê°„: [${objectInterval[0]}, ${objectInterval[1]})\n`;
                                        output += `  - ì¸ë±ìŠ¤ ê°œìˆ˜: ${objectInterval[1] - objectInterval[0]}\n`;
                                    }
                                } catch (e) {
                                    output += `  - ì¸ë±ìŠ¤ êµ¬ê°„ ì¶”ì¶œ ì‹¤íŒ¨: ${e.message}\n`;
                                }
                                
                                // ì²« ë²ˆì§¸ ì •ì  ìœ„ì¹˜
                                if (vertexCount > 0) {
                                    try {
                                        const firstVertex = roadObjectsMesh.vertices.get(0);
                                        output += `  - ì²« ë²ˆì§¸ ì •ì : (${firstVertex[0].toFixed(2)}, ${firstVertex[1].toFixed(2)}, ${firstVertex[2].toFixed(2)})\n`;
                                    } catch (e) {
                                        output += `  - ì •ì  ì •ë³´ ì¶”ì¶œ ì‹¤íŒ¨: ${e.message}\n`;
                                    }
                                }
                                
                            } catch (e) {
                                output += `ë„ë¡œì‹œì„¤ë¬¼ ìƒì„¸ ì •ë³´ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜: ${e.message}\n`;
                            }
                        }
                        
                        // ì „ì²´ ì‹œì„¤ë¬¼ í¬ê¸° ë¶„í¬ ë¶„ì„
                        if (objectCount > 1) {
                            output += `\nì‹œì„¤ë¬¼ ë¶„í¬:\n`;
                            const maxShow = Math.min(5, objectCount - 1);
                            for (let i = 0; i < maxShow; i++) {
                                try {
                                    const startIdx = roadObjectsMesh.road_object_start_indices.get(i);
                                    const endIdx = roadObjectsMesh.road_object_start_indices.get(i + 1);
                                    const objIndexCount = endIdx - startIdx;
                                    output += `  - ì‹œì„¤ë¬¼ ${i}: ${objIndexCount}ê°œ ì¸ë±ìŠ¤\n`;
                                } catch (e) {
                                    output += `  - ì‹œì„¤ë¬¼ ${i}: ë¶„ì„ ì‹¤íŒ¨\n`;
                                }
                            }
                            if (objectCount > maxShow + 1) {
                                output += `  ... ë° ${objectCount - maxShow - 1}ê°œ ì¶”ê°€ ì‹œì„¤ë¬¼\n`;
                            }
                        }
                    }
                } else {
                    output += "\n--- ë„ë¡œì‹œì„¤ë¬¼ ë©”ì‰¬ (RoadObjectsMesh) ---\n";
                    output += "âŒ ë„ë¡œì‹œì„¤ë¬¼ ë©”ì‰¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n";
                }
                
            } catch (e) {
                output += `RoadNetworkMesh ë¶„ì„ ì˜¤ë¥˜: ${e.message}\n`;
            }
            
            output += "\n";
            return output;
        }

        // ğŸ¯ **4. ë„ë¡œë³„ ìƒì„¸ ì •ë³´** (ì»¤ì„œ ë£°: ëŠìŠ¨í•œ ê²°í•©)
        function generateRoadDetailedInfo(map) {
            let output = "=".repeat(60) + "\n";
            output += "ğŸ›£ï¸ ë„ë¡œë³„ ìƒì„¸ ì •ë³´\n";
            output += "=".repeat(60) + "\n";
            
            try {
                const roads = Module.get_roads(map);
                if (roads && roads.size() > 0) {
                    const maxRoadsToShow = Math.min(5, roads.size());
                    output += `ì´ ${roads.size()}ê°œ ë„ë¡œ ì¤‘ ì²« ${maxRoadsToShow}ê°œ í‘œì‹œ:\n\n`;
                    
                    for (let i = 0; i < maxRoadsToShow; i++) {
                        const road = roads.get(i);
                        output += `ë„ë¡œ #${i + 1}:\n`;
                        output += `  - ID: ${road.id}\n`;
                        output += `  - ê¸¸ì´: ${road.length?.toFixed(3) ?? 'N/A'}m\n`;
                        output += `  - ì´ë¦„: ${road.name || 'Unnamed'}\n`;
                        output += `  - êµì°¨ë¡œ: ${road.junction || 'None'}\n`;
                        output += "\n";
                    }
                    
                    if (roads.size() > maxRoadsToShow) {
                        output += `... ë° ${roads.size() - maxRoadsToShow}ê°œ ì¶”ê°€ ë„ë¡œ\n\n`;
                    }
                } else {
                    output += "ë„ë¡œ ë°ì´í„° ì—†ìŒ\n\n";
                }
            } catch (e) {
                output += `ë„ë¡œ ì •ë³´ ì¶”ì¶œ ì˜¤ë¥˜: ${e.message}\n\n`;
            }
            
            return output;
        }

        // ğŸ¯ **5. êµì°¨ë¡œ ì •ë³´** (ì»¤ì„œ ë£°: ëª¨ë“ˆí™”ëœ ì½”ë“œ)
        function generateJunctionInfo(map) {
            let output = "=".repeat(60) + "\n";
            output += "ğŸš¦ êµì°¨ë¡œ ì •ë³´\n";
            output += "=".repeat(60) + "\n";
            
            try {
                const junctions = Module.get_junctions(map);
                if (junctions && junctions.size() > 0) {
                    const maxJunctionsToShow = Math.min(3, junctions.size());
                    output += `ì´ ${junctions.size()}ê°œ êµì°¨ë¡œ ì¤‘ ì²« ${maxJunctionsToShow}ê°œ í‘œì‹œ:\n\n`;
                    
                    for (let i = 0; i < maxJunctionsToShow; i++) {
                        const junction = junctions.get(i);
                        output += `êµì°¨ë¡œ #${i + 1}:\n`;
                        output += `  - ID: ${junction.id}\n`;
                        output += `  - ì´ë¦„: ${junction.name || 'Unnamed'}\n`;
                        output += "\n";
                    }
                    
                    if (junctions.size() > maxJunctionsToShow) {
                        output += `... ë° ${junctions.size() - maxJunctionsToShow}ê°œ ì¶”ê°€ êµì°¨ë¡œ\n\n`;
                    }
                } else {
                    output += "êµì°¨ë¡œ ë°ì´í„° ì—†ìŒ\n\n";
                }
            } catch (e) {
                output += `êµì°¨ë¡œ ì •ë³´ ì¶”ì¶œ ì˜¤ë¥˜: ${e.message}\n\n`;
            }
            
            return output;
        }

        // ğŸ¯ **6. ë©”ì‰¬ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„°** (ì»¤ì„œ ë£°: ì„±ëŠ¥ ìµœì í™”)
        function generateMeshGeometryData(roadNetworkMesh) {
            let output = "=".repeat(60) + "\n";
            output += "ğŸ“ ë©”ì‰¬ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„° (ìƒ˜í”Œ)\n";
            output += "=".repeat(60) + "\n";
            
            try {
                const lanesMesh = roadNetworkMesh.lanes_mesh;
                if (lanesMesh && lanesMesh.vertices && lanesMesh.vertices.size() > 0) {
                    const vertices = lanesMesh.vertices;
                    const indices = lanesMesh.indices;
                    
                    output += "--- ì •ì  ë°ì´í„° (ì²« 10ê°œ) ---\n";
                    const maxVertices = Math.min(10, vertices.size());
                    for (let i = 0; i < maxVertices; i++) {
                        const vertex = vertices.get(i);
                        output += `V${i}: (${vertex[0].toFixed(3)}, ${vertex[1].toFixed(3)}, ${vertex[2].toFixed(3)})\n`;
                    }
                    
                    output += "\n--- ì¸ë±ìŠ¤ ë°ì´í„° (ì²« 30ê°œ, ì‚¼ê°í˜•ë³„) ---\n";
                    const maxIndices = Math.min(30, indices.size());
                    for (let i = 0; i < maxIndices; i += 3) {
                        if (i + 2 < maxIndices) {
                            const i1 = indices.get(i);
                            const i2 = indices.get(i + 1);
                            const i3 = indices.get(i + 2);
                            output += `T${Math.floor(i/3)}: [${i1}, ${i2}, ${i3}]\n`;
                        }
                    }
                    
                    // ST ì¢Œí‘œ ì‹œìŠ¤í…œ ì •ë³´
                    if (lanesMesh.st_coordinates && lanesMesh.st_coordinates.size() > 0) {
                        output += "\n--- ST ì¢Œí‘œ ë°ì´í„° (ì²« 5ê°œ) ---\n";
                        const maxST = Math.min(5, lanesMesh.st_coordinates.size());
                        for (let i = 0; i < maxST; i++) {
                            const st = lanesMesh.st_coordinates.get(i);
                            output += `ST${i}: S=${st[0].toFixed(3)}, T=${st[1].toFixed(3)}\n`;
                        }
                    }
                    
                    // OBJ íŒŒì¼ í˜•ì‹ ì •ë³´
                    output += "\n--- OBJ íŒŒì¼ ìƒì„± ê°€ëŠ¥ ---\n";
                    output += `ì‚¬ìš©ë²•: mesh.get_obj() í˜¸ì¶œ\n`;
                    output += `ë°ì´í„° í¬ê¸°: ${lanesMesh.vertices.size()} ì •ì , ${lanesMesh.indices.size()} ì¸ë±ìŠ¤\n`;
                }
                
            } catch (e) {
                output += `ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„° ì¶”ì¶œ ì˜¤ë¥˜: ${e.message}\n`;
            }
            
            output += "\n";
            return output;
        }

        // ğŸ¯ **7. ì°¸ì¡°ì„  ë°ì´í„°** (ì»¤ì„œ ë£°: ë¹„ìš©-í˜œíƒ ë¶„ì„)
        function generateReflineData(map) {
            let output = "=".repeat(60) + "\n";
            output += "ğŸ“ ì°¸ì¡°ì„  (Refline) ë°ì´í„°\n";
            output += "=".repeat(60) + "\n";
            
            try {
                const reflineSegments = Module.get_refline_segments(map, 0.25);
                if (reflineSegments) {
                    output += `ì°¸ì¡°ì„  ì •ì  ìˆ˜: ${reflineSegments.vertices?.size() ?? 0}\n`;
                    output += `ì°¸ì¡°ì„  ì¸ë±ìŠ¤ ìˆ˜: ${reflineSegments.indices?.size() ?? 0}\n`;
                    
                    if (reflineSegments.vertices && reflineSegments.vertices.size() > 0) {
                        output += "\n--- ì°¸ì¡°ì„  ì •ì  (ì²« 10ê°œ) ---\n";
                        const maxRefVertices = Math.min(10, reflineSegments.vertices.size());
                        for (let i = 0; i < maxRefVertices; i++) {
                            const vertex = reflineSegments.vertices.get(i);
                            output += `R${i}: (${vertex[0].toFixed(3)}, ${vertex[1].toFixed(3)}, ${vertex[2].toFixed(3)})\n`;
                        }
                    }
                    
                    if (reflineSegments.indices && reflineSegments.indices.size() > 0) {
                        output += "\n--- ì°¸ì¡°ì„  ì¸ë±ìŠ¤ (ì²« 20ê°œ, ì„ ë¶„ë³„) ---\n";
                        const maxRefIndices = Math.min(20, reflineSegments.indices.size());
                        for (let i = 0; i < maxRefIndices; i += 2) {
                            if (i + 1 < maxRefIndices) {
                                const i1 = reflineSegments.indices.get(i);
                                const i2 = reflineSegments.indices.get(i + 1);
                                output += `L${Math.floor(i/2)}: [${i1}, ${i2}]\n`;
                            }
                        }
                    }
                }
                
            } catch (e) {
                output += `ì°¸ì¡°ì„  ë°ì´í„° ì¶”ì¶œ ì˜¤ë¥˜: ${e.message}\n`;
            }
            
            output += "\n";
            return output;
        }

        // ğŸ¯ **8. ë§µ ìœ„ì¹˜ ë¶„ì„ ê²°ê³¼** (ì»¤ì„œ ë£°: ì‹¤ìš©ì  ì •ë³´ ì œê³µ)
        function generateMapLocationAnalysis() {
            let output = "=".repeat(60) + "\n";
            output += "ğŸ—ºï¸ ë§µ ìœ„ì¹˜ ë¶„ì„ ê²°ê³¼\n";
            output += "=".repeat(60) + "\n";
            
            if (window.mapAnalysis) {
                const analysis = window.mapAnalysis;
                const bounds = analysis.bounds;
                const realOrigin = analysis.realOrigin;
                
                output += `ë§µ ê²½ê³„ (Three.js ì¢Œí‘œê³„):\n`;
                output += `  Xì¶•: ${bounds.min.x.toFixed(2)} ~ ${bounds.max.x.toFixed(2)} (í­: ${(bounds.max.x - bounds.min.x).toFixed(2)})\n`;
                output += `  Zì¶•: ${bounds.min.z.toFixed(2)} ~ ${bounds.max.z.toFixed(2)} (ë†’ì´: ${(bounds.max.z - bounds.min.z).toFixed(2)})\n`;
                output += `\n`;
                
                output += `ë§µ ì¤‘ì‹¬ì  (center_map=true):\n`;
                output += `  ìœ„ì¹˜: (${bounds.center.x.toFixed(2)}, ${bounds.center.z.toFixed(2)})\n`;
                output += `  í‘œì‹œìƒ‰: ë¹¨ê°„ìƒ‰ êµ¬ì²´\n`;
                output += `\n`;
                
                output += `ì‹¤ì œ OpenDRIVE ì›ì  (0,0):\n`;
                output += `  OpenDRIVE ì¢Œí‘œ: (0, 0)\n`;
                output += `  Three.js ì¢Œí‘œ: (${realOrigin.x.toFixed(2)}, ${realOrigin.z.toFixed(2)})\n`;
                output += `  ìœ„ì¹˜: ${analysis.quadrant}\n`;
                output += `  í‘œì‹œìƒ‰: ì£¼í™©ìƒ‰ ë‹¤ì´ì•„ëª¬ë“œ\n`;
                output += `\n`;
                
                // ì‚¬ë¶„ë©´ ì„¤ëª…
                output += `ì‚¬ë¶„ë©´ ë¶„ì„ (ë§µ ì¤‘ì‹¬ ê¸°ì¤€):\n`;
                if (analysis.quadrant.includes('1ì‚¬ë¶„ë©´')) {
                    output += `  ì‹¤ì œ ì›ì ì´ ë§µì˜ ìš°ìƒë‹¨ ì˜ì—­ì— ìœ„ì¹˜\n`;
                } else if (analysis.quadrant.includes('2ì‚¬ë¶„ë©´')) {
                    output += `  ì‹¤ì œ ì›ì ì´ ë§µì˜ ì¢Œìƒë‹¨ ì˜ì—­ì— ìœ„ì¹˜\n`;
                } else if (analysis.quadrant.includes('3ì‚¬ë¶„ë©´')) {
                    output += `  ì‹¤ì œ ì›ì ì´ ë§µì˜ ì¢Œí•˜ë‹¨ ì˜ì—­ì— ìœ„ì¹˜\n`;
                } else if (analysis.quadrant.includes('4ì‚¬ë¶„ë©´')) {
                    output += `  ì‹¤ì œ ì›ì ì´ ë§µì˜ ìš°í•˜ë‹¨ ì˜ì—­ì— ìœ„ì¹˜\n`;
                } else if (analysis.quadrant.includes('ì™¸ë¶€')) {
                    output += `  ì‹¤ì œ ì›ì ì´ ë§µ ì˜ì—­ ë°–ì— ìœ„ì¹˜\n`;
                    output += `  ì´ëŠ” center_map=trueë¡œ ì¸í•´ ë§µì´ ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™í–ˆê¸° ë•Œë¬¸\n`;
                }
                
                output += `\n`;
                output += `ì¢Œí‘œ ì˜¤í”„ì…‹ ì •ë³´:\n`;
                output += `  X ì˜¤í”„ì…‹: ${window.mapOffsetX?.toFixed(6) || 'N/A'}\n`;
                output += `  Y ì˜¤í”„ì…‹: ${window.mapOffsetY?.toFixed(6) || 'N/A'}\n`;
                output += `  ì´ ì˜¤í”„ì…‹ì€ ì‹¤ì œ ì§€ë¦¬ì  ì¢Œí‘œë¡œì˜ ë³€í™˜ì— ì‚¬ìš©ë¨\n`;
                
            } else {
                output += "ë§µ ë¶„ì„ ë°ì´í„°ê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n";
                output += "ì ì‹œ í›„ ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.\n";
            }
            
            output += "\n";
            output += "=".repeat(60) + "\n";
            output += "âœ… ëª¨ë“  libOpenDRIVE ë°ì´í„° ì¶”ì¶œ ì™„ë£Œ\n";
            output += "=".repeat(60) + "\n";
            
            return output;
        }

        /**
         * ì‚¬ìš©ìì—ê²Œ í”¼ë“œë°± ë©”ì‹œì§€ë¥¼ í‘œì‹œí•˜ëŠ” í—¬í¼ í•¨ìˆ˜
         * @param {string} message - í‘œì‹œí•  ë©”ì‹œì§€
         * @param {string} type - 'success' ë˜ëŠ” 'error'
         */
        function showFeedbackMessage(message, type = 'success') {
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = `message-popup ${type}-message`;
            feedbackDiv.textContent = message;
            document.body.appendChild(feedbackDiv);

            setTimeout(() => {
                feedbackDiv.style.transition = 'opacity 0.5s';
                feedbackDiv.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(feedbackDiv);
                }, 500);
            }, 3000); // 3ì´ˆ í›„ ì‚¬ë¼ì§
        }
        function showSuccess(message) {
            showFeedbackMessage(message, 'success');
        }
        function showError(message) {
            showFeedbackMessage(message, 'error');
        }

        // 'W' í‚¤ë¥¼ ëˆŒëŸ¬ ì™€ì´ì–´í”„ë ˆì„ ëª¨ë“œ í† ê¸€
        window.addEventListener('keydown', (event) => {
            if (event.key === 'w' || event.key === 'W') {
                const materials = [
                    lanesGroup, roadmarksGroup, roadObjectsGroup
                ].flatMap(group => group ? group.children : [])
                 .map(child => child.material);

                materials.forEach(material => {
                    if (material) {
                         material.wireframe = !material.wireframe;
                    }
                });
            }
            if (event.key === 'h' || event.key === 'H') {
                document.getElementById('controls')?.classList.toggle('hidden');
            }
        });

        // ğŸ¯ **ì¤‘ì‹¬ì  ë§ˆì»¤ ìƒì„± í•¨ìˆ˜** (ì»¤ì„œ ë£°: ë‹¨ì¼ ì±…ì„ ì›ì¹™)
        function createOriginMarker() {
            if (originMarker) {
                scene.remove(originMarker);
                originMarker.geometry.dispose();
                originMarker.material.dispose();
            }

            // ì¤‘ì‹¬ì ì— êµ¬ì²´ ë§ˆì»¤ ìƒì„± (ë¹¨ê°„ìƒ‰)
            const originGeometry = new THREE.SphereGeometry(5, 16, 16);
            const originMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0x330000,
                roughness: 0.3,
                metalness: 0.1
            });
            
            originMarker = new THREE.Mesh(originGeometry, originMaterial);
            
            // center_map: trueë¡œ ì¸í•œ ì¤‘ì‹¬ì  ìœ„ì¹˜
            originMarker.position.set(0, 0, 0);
            originMarker.userData = { 
                type: 'ë§µ ì¤‘ì‹¬ì  (center_map)',
                id: 'center-marker',
                isOrigin: true
            };
            
            scene.add(originMarker);
            console.log('ì¤‘ì‹¬ì  ë§ˆì»¤ ìƒì„± ì™„ë£Œ: (0, 0, 0)');
        }

        // ğŸ¯ **ì‹¤ì œ OpenDRIVE ì›ì  ë§ˆì»¤ ìƒì„±** (ì»¤ì„œ ë£°: ë°ì´í„° ì •í™•ì„±)
        function createOriginalOriginMarker() {
            if (originalOriginMarker) {
                scene.remove(originalOriginMarker);
                originalOriginMarker.geometry.dispose();
                originalOriginMarker.material.dispose();
            }

            // ì‹¤ì œ ì›ì  ìœ„ì¹˜ ê³„ì‚°
            const realOriginX = -window.mapOffsetX || 0;
            const realOriginZ = -window.mapOffsetY || 0; // OpenDRIVE Y -> Three.js Z
            
            // ì‹¤ì œ ì›ì ì— ë‹¤ì´ì•„ëª¬ë“œ ë§ˆì»¤ ìƒì„± (ì£¼í™©ìƒ‰)
            const diamondGeometry = new THREE.OctahedronGeometry(8, 0);
            const diamondMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff6600,
                emissive: 0x441100,
                roughness: 0.2,
                metalness: 0.2
            });
            
            originalOriginMarker = new THREE.Mesh(diamondGeometry, diamondMaterial);
            originalOriginMarker.position.set(realOriginX, 0, realOriginZ);
            originalOriginMarker.userData = { 
                type: 'ì‹¤ì œ OpenDRIVE ì›ì  (0,0)',
                id: 'real-origin-marker',
                isRealOrigin: true,
                realCoords: { x: 0, y: 0 }
            };
            
            scene.add(originalOriginMarker);
            console.log(`ì‹¤ì œ ì›ì  ë§ˆì»¤ ìƒì„± ì™„ë£Œ: OpenDRIVE (0,0) -> Three.js (${realOriginX.toFixed(2)}, ${realOriginZ.toFixed(2)})`);
            
            // ë§µ ë¶„ì„ ì •ë³´ ì¶œë ¥
            analyzeMapBounds();
        }

        // ğŸ¯ **ë§µ ê²½ê³„ ë¶„ì„ í•¨ìˆ˜** (ì»¤ì„œ ë£°: ì‹œìŠ¤í…œ ì‚¬ê³ )
        function analyzeMapBounds() {
            if (!lanesGroup || lanesGroup.children.length === 0) return;
            
            const boundingBox = new THREE.Box3();
            lanesGroup.children.forEach(mesh => {
                if (mesh && mesh.geometry) {
                    mesh.geometry.computeBoundingBox();
                    if (mesh.geometry.boundingBox && !mesh.geometry.boundingBox.isEmpty()) {
                        boundingBox.union(mesh.geometry.boundingBox);
                    }
                }
            });
            
            if (boundingBox.isEmpty()) return;
            
            const min = boundingBox.min;
            const max = boundingBox.max;
            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
            
            // ì‹¤ì œ ì›ì  ìœ„ì¹˜
            const realOriginX = -window.mapOffsetX || 0;
            const realOriginZ = -window.mapOffsetY || 0;
            
            // ì‚¬ë¶„ë©´ ë¶„ì„
            let quadrant = '';
            if (realOriginX >= min.x && realOriginX <= max.x && realOriginZ >= min.z && realOriginZ <= max.z) {
                // ì›ì ì´ ë§µ ë‚´ë¶€ì— ìˆëŠ” ê²½ìš°
                const centerX = center.x;
                const centerZ = center.z;
                
                if (realOriginX >= centerX && realOriginZ >= centerZ) quadrant = '1ì‚¬ë¶„ë©´ (ìš°ìƒë‹¨)';
                else if (realOriginX < centerX && realOriginZ >= centerZ) quadrant = '2ì‚¬ë¶„ë©´ (ì¢Œìƒë‹¨)';
                else if (realOriginX < centerX && realOriginZ < centerZ) quadrant = '3ì‚¬ë¶„ë©´ (ì¢Œí•˜ë‹¨)';
                else quadrant = '4ì‚¬ë¶„ë©´ (ìš°í•˜ë‹¨)';
            } else {
                // ì›ì ì´ ë§µ ì™¸ë¶€ì— ìˆëŠ” ê²½ìš°
                if (realOriginX > max.x && realOriginZ > max.z) quadrant = 'ë§µ ìš°ìƒë‹¨ ì™¸ë¶€';
                else if (realOriginX < min.x && realOriginZ > max.z) quadrant = 'ë§µ ì¢Œìƒë‹¨ ì™¸ë¶€';
                else if (realOriginX < min.x && realOriginZ < min.z) quadrant = 'ë§µ ì¢Œí•˜ë‹¨ ì™¸ë¶€';
                else if (realOriginX > max.x && realOriginZ < min.z) quadrant = 'ë§µ ìš°í•˜ë‹¨ ì™¸ë¶€';
                else if (realOriginX >= min.x && realOriginX <= max.x && realOriginZ > max.z) quadrant = 'ë§µ ìƒë‹¨ ì™¸ë¶€';
                else if (realOriginX >= min.x && realOriginX <= max.x && realOriginZ < min.z) quadrant = 'ë§µ í•˜ë‹¨ ì™¸ë¶€';
                else if (realOriginX > max.x && realOriginZ >= min.z && realOriginZ <= max.z) quadrant = 'ë§µ ìš°ì¸¡ ì™¸ë¶€';
                else if (realOriginX < min.x && realOriginZ >= min.z && realOriginZ <= max.z) quadrant = 'ë§µ ì¢Œì¸¡ ì™¸ë¶€';
            }
            
            console.log('ğŸ—ºï¸ ë§µ ë¶„ì„ ê²°ê³¼:');
            console.log(`  ë§µ ê²½ê³„: X(${min.x.toFixed(2)} ~ ${max.x.toFixed(2)}), Z(${min.z.toFixed(2)} ~ ${max.z.toFixed(2)})`);
            console.log(`  ë§µ ì¤‘ì‹¬: (${center.x.toFixed(2)}, ${center.z.toFixed(2)})`);
            console.log(`  ì‹¤ì œ ì›ì  ìœ„ì¹˜: (${realOriginX.toFixed(2)}, ${realOriginZ.toFixed(2)})`);
            console.log(`  ì›ì ì€ ${quadrant}ì— ìœ„ì¹˜`);
            
            // ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
            window.mapAnalysis = {
                bounds: { min, max, center },
                realOrigin: { x: realOriginX, z: realOriginZ },
                quadrant: quadrant
            };
        }

        // ğŸ¯ **ì¢Œí‘œì¶• ìƒì„± í•¨ìˆ˜** (ì»¤ì„œ ë£°: ëª¨ë“ˆí™”ëœ ì½”ë“œ)
        function createCoordinateAxes() {
            if (coordinateAxes) {
                scene.remove(coordinateAxes);
                coordinateAxes.children.forEach(child => {
                    child.geometry.dispose();
                    child.material.dispose();
                });
            }

            coordinateAxes = new THREE.Group();
            coordinateAxes.name = "CoordinateAxes";

            const axisLength = 50;
            const axisWidth = 2;

            // Xì¶• (ë¹¨ê°„ìƒ‰) - OpenDRIVE ë™ìª½ ë°©í–¥
            const xAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
            const xAxisMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
            xAxis.position.set(axisLength / 2, 0, 0);
            xAxis.rotation.z = -Math.PI / 2;
            xAxis.userData = { type: 'Xì¶• (ë™ìª½)', axis: 'X' };

            // Yì¶• (ì´ˆë¡ìƒ‰) - OpenDRIVE ë¶ìª½ ë°©í–¥ (Three.js Zì¶•)
            const yAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
            const yAxisMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
            yAxis.position.set(0, 0, axisLength / 2);
            yAxis.rotation.x = Math.PI / 2;
            yAxis.userData = { type: 'Yì¶• (ë¶ìª½)', axis: 'Y' };

            // Zì¶• (íŒŒë€ìƒ‰) - OpenDRIVE ìœ„ìª½ ë°©í–¥ (Three.js Yì¶•)
            const zAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8);
            const zAxisMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
            zAxis.position.set(0, axisLength / 2, 0);
            zAxis.userData = { type: 'Zì¶• (ìœ„ìª½)', axis: 'Z' };

            // ì¶• ëì— í™”ì‚´í‘œ ì¶”ê°€
            const arrowSize = 8;
            
            // Xì¶• í™”ì‚´í‘œ
            const xArrowGeometry = new THREE.ConeGeometry(arrowSize, arrowSize * 2, 8);
            const xArrow = new THREE.Mesh(xArrowGeometry, xAxisMaterial);
            xArrow.position.set(axisLength, 0, 0);
            xArrow.rotation.z = -Math.PI / 2;

            // Yì¶• í™”ì‚´í‘œ
            const yArrow = new THREE.Mesh(xArrowGeometry, yAxisMaterial);
            yArrow.position.set(0, 0, axisLength);
            yArrow.rotation.x = Math.PI / 2;

            // Zì¶• í™”ì‚´í‘œ
            const zArrow = new THREE.Mesh(xArrowGeometry, zAxisMaterial);
            zArrow.position.set(0, axisLength, 0);

            coordinateAxes.add(xAxis, yAxis, zAxis, xArrow, yArrow, zArrow);
            coordinateAxes.userData = { type: 'ì¢Œí‘œì¶•', id: 'coordinate-axes' };
            
            scene.add(coordinateAxes);
            console.log('ì¢Œí‘œì¶• ìƒì„± ì™„ë£Œ: X(ë¹¨ê°•/ë™ìª½), Y(ì´ˆë¡/ë¶ìª½), Z(íŒŒë‘/ìœ„ìª½)');
        }

        function clearScene() {
            if (lanesGroup) scene.remove(lanesGroup);
            if (roadmarksGroup) scene.remove(roadmarksGroup);
            if (roadObjectsGroup) scene.remove(roadObjectsGroup);
            if (gridHelper) scene.remove(gridHelper);
            if (originMarker) scene.remove(originMarker);
            if (originalOriginMarker) scene.remove(originalOriginMarker);
            if (coordinateAxes) scene.remove(coordinateAxes);

            lanesGroup?.children.forEach(child => child.geometry.dispose());
            roadmarksGroup?.children.forEach(child => child.geometry.dispose());
            roadObjectsGroup?.children.forEach(child => child.geometry.dispose());
            
            // ì›ì  ë§ˆì»¤ë“¤ ì •ë¦¬
            if (originMarker) {
                originMarker.geometry.dispose();
                originMarker.material.dispose();
            }
            if (originalOriginMarker) {
                originalOriginMarker.geometry.dispose();
                originalOriginMarker.material.dispose();
            }
            
            // ì¢Œí‘œì¶• ì •ë¦¬
            if (coordinateAxes) {
                coordinateAxes.children.forEach(child => {
                    child.geometry.dispose();
                    child.material.dispose();
                });
            }
        }

        function onMouseClick(event) {
            // ... ê¸°ì¡´ ì½”ë“œ ...
        }
    </script>
</body>
</html> 